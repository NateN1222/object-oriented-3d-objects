    //**********verifying that my problem isn't that the data read from the file isn't accurate (it is)*************

    // this is the exact data from the obj file I read
    float vertices[36] = {0,  -0.525731,  0.850651,
                0.850651,  0,  0.525731,
                0.850651,  0,  -0.525731,
                -0.850651,  0,  -0.525731,
                -0.850651,  0,  0.525731,
                -0.525731,  0.850651,  0,
                0.525731,  0.850651,  0,
                0.525731,  -0.850651,  0,
                -0.525731,  -0.850651,  0,
                0,  -0.525731,  -0.850651,
                0,  0.525731,  -0.850651,
                0,  0.525731,  0.850651};

    int elements[60] = {2,  3,  7,
                2,  8,  3,
                4,  5,  6,
                5,  4,  9,
                7,  6,  12,
                6,  7,  11,
                10,  11,  3,
                11,  10,  4,
                8,  9,  10,
                9,  8,  1,
                12,  1,  2,
                1,  12,  5,
                7,  3,  11,
                2,  7,  12,
                4,  6,  11,
                6,  5,  12,
                3,  8,  10,
                8,  2,  1,
                4,  10,  9,
                5,  9,  1};
    // comparing it to the data I read, getting the size of all elements in a fool-proof way
    int totalSize = 0;
    int totalTSize = 0;
    for (int i = 0; i < 36; i++){
        printf("%f:%f:%s\n",vertices[i],iso.vertices[i],(vertices[i]==iso.vertices[i])?"true":"false");
        totalSize += sizeof(iso.vertices[i]);
    }

    for (int i = 0; i < 60; i++){
        printf("%i:%i:%s\n",elements[i],iso.triangles[i],(elements[i]==iso.triangles[i])?"true":"false");
        totalTSize += sizeof(iso.triangles[i]);
    }
    printf("vcount:%i\nvsize:%i",iso.verticeCount,totalSize);
    printf("\ntcount:%i\ntsize:%i\n",iso.triangleCount,totalTSize);


    printf("\n\n%i\n\n",sizeof(vertices));
    printf("\n\n%i\n\n",sizeof(elements));
    // **************************************************************************************************************




#define GLEW_STATIC
#include <GL/glew.h>

#include <GLFW/glfw3.h>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>

#include <chrono>
#include <cmath>

#define SCALE_MPOS_X 1.0f
#define SCALE_MPOS_Y 1.0f
#define WIDTH 800
#define HEIGHT 600
// missing line between 1 and 8
// missing line between 10 and 2
// missing line between 4 and 9

// extra line between 0 and 11


extern "C" {
#include "objReader.h"
}

typedef struct {
    GLuint program;
    GLuint frag;
    GLuint vert;
} shaders;
shaders compileShaders(){
    // Shader sources
    const GLchar* vertexSource =
        "#version 150 core\n"
        "in vec3 position;"
        "in vec3 color;"
        "out vec3 Color;"
        "uniform mat4 model;"
        "uniform mat4 view;"
        "uniform mat4 proj;"
        "void main()"
        "{"
         //   "gl_Position = vec4(position,1.0);"
            "gl_Position = proj * view * model * vec4(position, 1.0);"
            "Color = color;"
        "}";

    const GLchar* fragmentSource =
        "#version 150 core\n"
        "in vec3 Color;"
        "out vec4 outColor;"
        "void main()"
        "{"
        "outColor = vec4(Color, 1.0);"
        "}";
        // Create and compile the vertex shader
    GLint status;

    GLuint vertexShader = glCreateShader(GL_VERTEX_SHADER);
    glShaderSource(vertexShader, 1, &vertexSource, NULL);
    glCompileShader(vertexShader);

    char buffer[512];

    glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &status);
    glGetShaderInfoLog(vertexShader, 512, NULL, buffer);

    if(status == GL_TRUE){
        printf("vertex shader compiled.\n");
    } else{
        printf("\n\n%s\n\n",buffer);
    }

    GLuint fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(fragmentShader, 1, &fragmentSource, NULL);
    glCompileShader(fragmentShader);

    glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &status);

    glGetShaderInfoLog(fragmentShader, 512, NULL, buffer);

    if(status == GL_TRUE){
        printf("frag shader compiled.\n");
    } else{
        printf("\n\n%s\n\n",buffer);
    }

    // Link the vertex and fragment shader into a shader program
    GLuint shaderProgram = glCreateProgram();
    glAttachShader(shaderProgram, vertexShader);
    glAttachShader(shaderProgram, fragmentShader);
    glBindFragDataLocation(shaderProgram, 0, "outColor");

    glLinkProgram(shaderProgram);
    glUseProgram(shaderProgram);

    shaders ret;
    ret.frag = fragmentShader;
    ret.program = shaderProgram;
    ret.vert = vertexShader;

    return ret;
}

//float* temp = (float*) malloc(sizeof(float)); // so it won't bitch when I free() the first time

GLint lastVertice = (2*(6*sizeof(GL_FLOAT)))+3*sizeof(float);
GLint thisVertice;

int counter = 0;

obj iso = readObjFile("iso.obj");
const float red[] = {1,0,0};
const float blue[] = {0,0,1};

bool clicked = false;
bool first = true;

void mbutton_callback(GLFWwindow* window, int button, int action, int mods){

    if(button == GLFW_MOUSE_BUTTON_1 && !clicked){
        clicked = true;
        first = true;
        glfwGetCursorPos(window,0,0);


    } else{
        clicked = false;

    }


}

double dx = 0;
double dy = 0;

float cum_x;
float cum_y;

double lastX;
double lastY;


void mpos_callback(GLFWwindow* window, double xpos, double ypos){
    if(clicked == true){
        if (first == true){
            lastX = xpos;
            lastY = ypos;
            first = false;
        } else{
            dx = (lastX-xpos)*SCALE_MPOS_X;
            dy = (lastY-ypos)*SCALE_MPOS_Y;

            cum_x += (float) dx;
            cum_y += (float) dy;

            lastX = xpos;
            lastY = ypos;
            printf("%F,%F\n",dx,dy);
        }
    }
}

void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods){

    //  void glBufferSubDataâ€‹(enum target, intptr offset, sizeiptr size, const void *data)
    if (key == GLFW_KEY_PAGE_UP && action == GLFW_RELEASE && counter < iso.verticeCount / 6){

        counter = counter + 1;
        printf(" \n %i",counter);

        thisVertice = (counter*(6*sizeof(GL_FLOAT)))+3*sizeof(float);

        glBufferSubData(GL_ARRAY_BUFFER,lastVertice,3*sizeof(float),blue);
        glBufferSubData(GL_ARRAY_BUFFER,thisVertice,3*sizeof(float),red);

        lastVertice = thisVertice;

    }


    if(key == GLFW_KEY_ENTER){

        int input;
        printf("\nInput vertice to make red:");
        scanf("%d",&input);

        if (input < iso.verticeCount/6 && input >= 0){

            thisVertice = (input*(6*sizeof(GL_FLOAT)))+3*sizeof(float);

            glBufferSubData(GL_ARRAY_BUFFER,lastVertice,3*sizeof(float),blue);
            glBufferSubData(GL_ARRAY_BUFFER,thisVertice,3*sizeof(float),red);

            lastVertice = thisVertice;

        } else{
            printf("\nNumber out of range.");
        }
    }



    if (key == GLFW_KEY_PAGE_DOWN && action == GLFW_RELEASE && counter != 0){

        counter = counter - 1;
        printf("\n %i",counter);


        thisVertice = (counter*(6*sizeof(GL_FLOAT)))+3*sizeof(float);
        glBufferSubData(GL_ARRAY_BUFFER,thisVertice,3*sizeof(float),red);
        glBufferSubData(GL_ARRAY_BUFFER,lastVertice,3*sizeof(float),blue);
        lastVertice = thisVertice;

//        glBufferData(GL_ARRAY_BUFFER, iso.verticeCount*sizeof(float),temp, GL_STATIC_DRAW);
    }

}

int main(){
    // load the obj file
    //auto t_start = std::chrono::high_resolution_clock::now();

    //iso.verticeCount = iso.verticeCount;
    //iso.triangleCount = iso.triangleCount;


    // init window
    glfwInit();

    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 2);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
    glfwWindowHint(GLFW_RESIZABLE, GL_FALSE);
    GLFWwindow* window = glfwCreateWindow(WIDTH, HEIGHT, "OpenGL",NULL,NULL); // Windowed
    glfwMakeContextCurrent(window);

    glewExperimental = GL_TRUE;
    glewInit();

    glfwSetKeyCallback(window, key_callback);
    glfwSetMouseButtonCallback(window,mbutton_callback);
    glfwSetCursorPosCallback(window,mpos_callback);
    // compile shaders
    shaders programs = compileShaders();
    GLuint shaderProgram = programs.program;
    GLuint vertexShader = programs.vert;
    GLuint fragmentShader = programs.frag;



    // Create Vertex Array Object
    GLuint vao;
    glGenVertexArrays(1, &vao);
    glBindVertexArray(vao);

    // Create a Vertex Buffer Object and copy the vertex data to it
    GLuint vbo;
    glGenBuffers(1, &vbo);
    glBindBuffer(GL_ARRAY_BUFFER, vbo);

    printf("vcount: %i", iso.verticeCount);

    glBufferData(GL_ARRAY_BUFFER, iso.verticeCount*sizeof(float), iso.vertices, GL_STATIC_DRAW);

    // Create a Element Buffer Object and copy the element data to it
    GLuint ebo;
    glGenBuffers(1, &ebo);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo); // Useful because you could change which buffers are used on the fly
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, iso.triangleCount*sizeof(GL_UNSIGNED_INT), (void*) iso.triangles, GL_STATIC_DRAW);

    // Specify the layout of the vertex data
    GLint posAttrib = glGetAttribLocation(shaderProgram, "position"); // the compiled program knows what inputs it has (?)
    glEnableVertexAttribArray(posAttrib);
    glVertexAttribPointer(posAttrib, 3, GL_FLOAT, GL_FALSE, 6*sizeof(GL_FLOAT), 0);

    GLint colAttrib = glGetAttribLocation(shaderProgram, "color");
    glEnableVertexAttribArray(colAttrib);
    glVertexAttribPointer(colAttrib, 3, GL_FLOAT, GL_FALSE, 6*sizeof(GL_FLOAT), (void*) (3*sizeof(GL_FLOAT)));

    // adding standard transforms, making it rotate

    GLint uniModel = glGetUniformLocation(shaderProgram, "model");
    // Set up projection
    glm::mat4 view = glm::lookAt(
        glm::vec3(1.2f, 1.2f, 1.2f),
        glm::vec3(0.0f, 0.0f, 0.0f),
        glm::vec3(0.0f, 0.0f, 1.0f)
    );
    GLint uniView = glGetUniformLocation(shaderProgram, "view");
    glUniformMatrix4fv(uniView, 1, GL_FALSE, glm::value_ptr(view));

    glm::mat4 proj = glm::perspective(glm::radians(45.0f), 800.0f / 600.0f, 1.0f, 10.0f);

    GLint uniProj = glGetUniformLocation(shaderProgram, "proj");
    glUniformMatrix4fv(uniProj, 1, GL_FALSE, glm::value_ptr(proj));

    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);


    while(!glfwWindowShouldClose(window)){

        //auto t_now = std::chrono::high_resolution_clock::now();
        //float time = std::chrono::duration_cast<std::chrono::duration<float>>(t_now - t_start).count();

        glClear(GL_COLOR_BUFFER_BIT);


        glm::mat4 model;
        model = glm::scale(model, glm::vec3(.01, .01, .01));
        glUniformMatrix4fv(uniModel, 1, GL_FALSE, glm::value_ptr(model));

        model = glm::rotate(
            model,
            cum_y,
            glm::vec3(1.0f, 0.0f, 0.0f)
        );


        model = glm::rotate(
            model,
            cum_x,
            glm::vec3(0.0f, 1.0f, 0.0f)
        );


        glUniformMatrix4fv(uniModel, 1, GL_FALSE, glm::value_ptr(model));

        glClearColor(0.0f, 0.0f, 0.0f, 1.0f); // black

         glDrawElements(
                 GL_TRIANGLES,      // mode
             iso.triangleCount,    // count
             GL_UNSIGNED_INT,   // type
             (void*) 0          // element array buffer offset
        );

        glfwSwapBuffers(window);
        glfwPollEvents();
    }

    glDeleteProgram(shaderProgram);
    glDeleteShader(fragmentShader);
    glDeleteShader(vertexShader);
    glDeleteBuffers(1, &vbo);
    glDeleteVertexArrays(1, &vao);
    free(iso.vertices); // in order to know the data from my reader would be sequential I had to malloc it myself
    free(iso.triangles);
    return 0;
}



